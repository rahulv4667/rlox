import sys
import os

def define_type(code_lines: list, base_class: str, class_name: str, fields: str):
    code_lines.append('\n')
    code_lines.append(f"\tpublic static class {class_name} extends {base_class} {{")
    code_lines.append(f"\n\t\tpublic {class_name}({fields}) {{\n")

    field_list = fields.split(',')
    for field in field_list:
        field = field.strip()

        # last one in field_sep is variable name
        field_sep = field.split(' ')
        code_lines.append(f"\t\t\tthis.{field_sep[-1]} = {field_sep[-1]};")

    # closing constructor
    code_lines.append("\n\t\t}\n")

    # visitor pattern
    code_lines.append("\t\t@Override")
    code_lines.append("\t\tpublic <R> R accept(Visitor<R> visitor) {")
    code_lines.append(f"\t\t\treturn visitor.visit{class_name}{base_class}(this);")
    code_lines.append("\t\t}\n")

    for field in field_list:
        field = field.strip()

        code_lines.append(f'\t\tpublic final {field};')
    
    # closing static class
    code_lines.append("\n\t}")


def define_visitor(code_lines: list, base_class: str, types: list):
    code_lines.append('\n')
    code_lines.append('\tpublic interface Visitor<R> {\n')

    for tp in types:
        [class_name, fields] = tp.split(':')
        class_name = class_name.strip()
        fields = fields.strip()

        code_lines.append(f"\t\tR visit{class_name}{base_class}({class_name} {base_class.lower()});")

    code_lines.append('\n\t}')


def define_ast(output_dir: str, base_class: str, types: list):
    if not os.path.isdir(output_dir+"/Parser"):
        os.mkdir(output_dir+"/Parser")
    path = output_dir + "/Parser/" + base_class + ".java"
    fh = open(path, "w")
    
    code_lines = list()
    code_lines.append("// This file is auto generated by generate_ast.py")
    code_lines.append("package rlox.Parser;")
    code_lines.append('\n')
    code_lines.append('import java.util.List;')
    code_lines.append('import rlox.Scanner.*;')
    code_lines.append('\n')

    code_lines.append('public abstract class ' + base_class + ' {')

    # visitor
    define_visitor(code_lines, base_class, types)

    # the AST classes
    for tp in types:
        [class_name, fields] = tp.split(':')
        class_name = class_name.strip()
        fields = fields.strip()

        define_type(code_lines, base_class, class_name, fields)

    # base accept method
    code_lines.append("\n\tpublic abstract <R> R accept(Visitor<R> visitor);")

    # closing base abstract class
    code_lines.append('}\n')

    fh.write('\n'.join(code_lines))




if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: generate_ast.py <path to source>")
        sys.exit(64)

    output_dir = sys.argv[1]
    define_ast(output_dir, "Expr", [
        "Assign     : Token name, Expr value",
        "Binary     : Expr left, Token operator, Expr right",
        "Call       : Expr callee, Token paren, List<Expr> arguments",
        "Get        : Expr object, Token name",
        "Grouping   : Expr expression",
        "Literal    : Object value",
        "Logical    : Expr left, Token operator, Expr right",
        "Set        : Expr object, Token name, Expr value",
        "Super      : Token keyword, Token method",
        "This       : Token keyword",
        "Unary      : Token operator, Expr right",
        "Variable   : Token name"
    ])

    define_ast(output_dir, "Stmt", [
        "Block      : List<Stmt> statements",
        "Class      : Token name, Expr.Variable superclass, List<Stmt.Function> methods",
        "Expression : Expr expression",
        "Function   : Token name, List<Token> params, List<Stmt> body",
        "If         : Expr condition, Stmt thenBranch, Stmt elseBranch",
        "Print      : Expr expression",
        "Return     : Token keyword, Expr value",
        "Var        : Token name, Expr initializer",
        "While      : Expr condition, Stmt body"
    ])